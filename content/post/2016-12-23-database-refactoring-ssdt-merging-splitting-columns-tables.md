+++
title=  "Grafting and Splicing"
date =  "2016-12-23"
tags = ["Refactoring", "SSDT"]
series = ["Refactoring Databases with SSDT"]
draft = true
+++

Grafting is the process of attaching a cutting, or scion, of one tree to the base, or rootstock, of another to proruce a new tree with characteristics of both.

![Grafting](https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Graft_182_%28PSF%29.png/640px-Graft_182_%28PSF%29.png "Grafting")

This article, stretching the horticultural analogy to breaking point, will look at the techniques for making more complex structural changes to our databases, such as splitting and merging columns and tables, substituting primary keys, and moving columns between tables.

## Merging Columns

For any number of reasons, we might decide to merge two columns into a single one. In this example, we'll merge the `FirstName` and `LastName` columns in the `dbo.Customer` table into a new column `FullName`. It is a simple matter to add the new column name and delete the old ones, but what about the data?

```sql
CREATE TABLE [dbo].[Customer] (
    [CustomerId]   INT           NOT NULL,
    --[FirstName]    NVARCHAR (40) NOT NULL,
    --[LastName]     NVARCHAR (20) NOT NULL,
    [FullName]	   NVARCHAR (60) NOT NULL,
```
Deploying the project as is would result in the `FirstName` and `LastName` columns being dropped, and the `FullName` column being created. This latter operation would of course fail, as `FullName` is defined to be `NOT NULL`, and we aren't supplying any values.

One approach would be to make the change in two stages, adding the new column, manually or otherwise copying the data across, and then dropping the old ones. However, by using the "Pre-Deployment" and "Post-Deployment" facilities in SSDT, we can do all of this in a single step without losing our data.

### Pre and Post Deployment Scripts

Pre-deployment and post-deployment scripts allow us to add additional instructions to be executed before and after the deployment script generated by comparing the database project to the target database. Since we are defining "instructions" rather than "objects", these scripts will need to be written in a _procedural_ rather than a _declarative_ manner. There is some pretty sketchy documentation about this feature on MSDN [here](https://msdn.microsoft.com/en-US/library/jj889461(v=vs.103).aspx "How to: Specify Predeployment or Postdeployment Scripts").

A single database project can contain only one pre-deployment script and one post-deployment script, but this limitation is alleviated by allowing us to "include" other scripts throught the use of the `:r` syntax of `sqlcmd`. 

Pre-deployment and post-deployment scripts aren't created by default in a new database project, but can be added through the "New Item" dialog.

![Add script dialog](http://aksidjenakfjg.s3.amazonaws.com/ssdt-refactoring-part-3/add-script-dialog.PNG "Pre-deployment and post-deployment scripts in the New Item dialog")

These scripts are identified with special "Build Actions" in SSDT.

![Pre-deployment script showing Build Action](http://aksidjenakfjg.s3.amazonaws.com/ssdt-refactoring-part-3/pre-deploy-build-action.PNG "Pre-deployment script showing build action")

![Post-deployment script showing Build Action](http://aksidjenakfjg.s3.amazonaws.com/ssdt-refactoring-part-3/post-deploy-build-action.PNG "Post-deployment script showing build action")


As a matter of course, I try to avoid including any logic in the pre-deploy and post-deploy scripts themselves, and simply allow these to reference other, named, scripts that do specific tasks. As hinted at above, I tend create separate folders for pre-deploy and post-deploy actions, then create sub-folders under these to hold the scripts referenced by the "main" pre and post deployment scripts. 

```bat
>tree /f Scripts
Folder PATH listing
Volume serial number is 6F6F-14E6
C:\USERS\ARAPAIMA\PROJECTS\REFACTORING.CHINOOK\REFACTORING.CHINOOK\SCRIPTS
├───Post-deploy
│   │   Post-Deploy.sql
│   │
│   └───Refactoring
│           merge-first-name-and-last-name.sql
│
└───Pre-deploy
    │   Pre-Deploy.sql
    │
    └───Refactoring
            merge-first-name-and-last-name.sql
```
These "sub-scripts" all have build action "None"; they get included at build time via the `:r` directive and relative paths.
```sql
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/

:r .\Refactoring\merge-first-name-and-last-name.sql
```

In "real life", the files themselves might have ticket numbers or other identifiers in the names, to enable us to trace where the requirement came from.

### Using Pre-deployment and Post-deployment scripts to save data during a schema change

Having covered all that, the outline plan for our deployment is to:

* Save the data we need into a temporary table during the pre-deployment script
* Allow SSDT to make the schema changes
* Repopulate the new column using our saved data.

Introduce Calculated Column

• Introduce Surrogate Key

• Merge Columns

• Merge Tables

• Move Column



• Replace Column

• Replace One-to-Many With Associative Table

• Replace Surrogate Key With Natural Key

• Split Column

• Split Table